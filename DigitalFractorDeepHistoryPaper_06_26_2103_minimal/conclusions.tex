In order to access deep memory while simultaneously conserving computational resources, we have modified the Grunwald algorithm by partitioning it into bins. In these bins, only the average input signal values and summed Grunwald weights are stored-- the individual values are discarded to conserve memory and to make the computation more efficient. We have implemented this algorithm in C++ on a desktop computer. 

Numerical simulations demonstrate that the average Grunwald algorithm achieves an improvement of about a factor of $3$ in constant phase bandwidth ($\pm 10^\circ$) in a fair comparison to the state-of-the-art algorithm, the continued fraction expansion (CFE), and its most commonly used input signal history depth (10 steps). Allowing the number of bins to be limited by the number of time steps our simulation could handle, the average Grunwald algorithm still makes a $2$ to $2.5$ decade constant phase bandwidth improvement with only $20$ binned input signal history registers. 

Furthermore, during runtime, the number of flops per time step and the memory required both scale as $N_b$, the number of bins, which we have tested at $10$ to $20$. There is a one time initialization cost where the number of flops scales as $N_h$, the total number of historical time steps stored within the bins, which may be on the order of millions. Exponential binning strategies performed well at any number of bins. 

To prevent aliasing, data is often filtered using a low-pass filter. The attenuation at high frequencies is truncated where the signal is below the sensitivity of the analog-to-digital converter. This frequency of truncation is set to be the Nyquist frequency, equal to twice the sampling rate. The frequency band just lower than the Nyquist frequency in which there is significant attenuation due to the low-pass filter is called the oversampling region. It is beneficial for the input function to gradually go to zero within this region rather than making a sharp turn at the end of the region because limiting the magnitude of the input function over the oversampling region is what prevents aliasing. If the function has a lower value over the oversampling region, then a lower order filter function can be used. This introduces less noise in the phase, which is important in a fractor which must be of constant phase over a large bandwidth. 

The ultimate goal of this work is to prepare the algorithm to be used in a {\bf MCU}. Currently average Grunwald algorithm has been implemented as a numerical integration and differentiation package in C++. Our continuing goal will be to package it for a {\bf MCU} and use it as a control element in a mechanical environment.  

{\bf What is an MCU anyway? I got the term from an email you sent. Is this the right term?}