In order to access deep memory while simultaneously conserving computational resources, we have modified the Gr{\"u}nwald algorithm by partitioning it into bins. In these bins, only the average input signal values and summed Gr{\"u}nwald weights are stored-- the individual values are discarded to conserve memory and to make the computation more efficient. We have implemented this algorithm in C++ on a desktop computer. 

Numerical simulations demonstrate that the average Gr{\"u}nwald algorithm achieves an improvement of about a factor of $3$ in constant phase bandwidth ($\pm 10^\circ$) in a fair comparison to the state-of-the-art algorithm, the Infinite Impulse Response (IIR), with its most commonly used input signal history depth (10 steps). Allowing the number of bins to be limited by the number of time steps our simulation could handle, the average Gr{\"u}nwald algorithm still makes a $2$ to $2.5$ decade constant phase bandwidth improvement over the IIR with only $20$ binned input signal history registers. 

Furthermore, during runtime, the number of flops per time step and the memory required both scale as $N_b$, the number of bins, which we have tested at $10$ to $20$. There is a one time initialization cost where the number of flops scales as $N_h$, the total number of historical time steps stored within the bins, which may be on the order of millions. Exponential binning strategies performed well at any number of bins. 

{\bf I rewrote this. Is it right?}
Beyond the additional bandwidth, the average Grunwald algorithm has a second advantage over the IIR algorithm. Commonly a low-pass filter is used to prevent aliasing. The broad roll-off  in phase of the average Grunwald algorithm at high frequencies would allow the Nyquist frequency to be set high when chosing an oversampling region, minimally truncating the bandwidth with the low-pass filter. Alternatively a lower order filter could be chosen, minimally disrupting the phase response. This is in contrast to the sharp plumet in phase of the IIR algorithm at high frequencies, which causes aliasing unless the highest half decade in frequency is filtered.

%To prevent aliasing, data is often filtered using a low-pass filter. The attenuation at high frequencies is truncated where the signal is
% below the sensitivity of the analog-to-digital converter. This frequency of truncation is set to be the Nyquist frequency, equal to twice
% the sampling rate. The frequency band just lower than the Nyquist frequency in which there is significant attenuation due to the low
%-pass filter is called the oversampling region. It is beneficial for the input function to gradually go to zero within this region rather than
% making a sharp turn at the end of the region because limiting the magnitude of the input function over the oversampling region is what 
%prevents aliasing. If the function has a lower value over the oversampling region, then a lower order filter function can be used. This
% introduces less noise in the phase, which is important in a fractor which must be of constant phase over a large bandwidth. 

The ultimate goal of this work is to prepare the algorithm to be used in an mcu. Currently average Gr{\"u}nwald algorithm has been implemented as a numerical integration and differentiation package in C++. Our continuing goal will be to package it for an mcu and use it as a control element in a mechanical environment.  